load("@bazel_skylib//rules:common_settings.bzl", "string_setting", "string_flag")
load("@rules_cc//cc/toolchains:actions.bzl", "cc_action_type_set")
load("@rules_cc//cc/toolchains:artifacts.bzl", "cc_artifact_name_pattern")
load("@rules_cc//cc/toolchains/impl:documented_api.bzl", "cc_args_list")
load("//toolchain/bootstrap:declare_toolchains.bzl", declare_bootstrap_toolchains = "declare_toolchains")
load(":declare_toolchains.bzl", "declare_toolchains")

package(default_visibility = ["//toolchain:__subpackages__"])

# TODO(cerisier): Find a better name ?
# This should be the semantic for "what are we building ?"
# Runtimes without dependencies, runtimes with dependencies, user programs with runtime dependencies...
string_setting(
    name = "runtime_stage",
    values = [
        "stage0", # depend on compiler-only: CRTs, builtins, libc, static libraries.
        "stage1", # depends on above: libunwind
        # "stage2", # depends on above: libc++abi
        # "stage3", # depends on above: libc++
        "complete", # depends on above: user programs.
    ],
    build_setting_default = "complete",
)

# Controls whether targets are built with bootstrapped toolchain or prebuilt toolchain.
string_flag(
    name = "source",
    values = [
        "bootstrapped",
        "prebuilt",
    ],
    build_setting_default = "prebuilt",
)

config_setting(
    name = "runtimes_all",
    flag_values = {
        ":runtime_stage": "complete",
    },
)

config_setting(
    name = "runtimes_stage1",
    flag_values = {
        ":runtime_stage": "stage1",
    },
)

config_setting(
    name = "runtimes_none",
    flag_values = {
        ":runtime_stage": "stage0",
    },
)

config_setting(
    name = "prebuilt_toolchain",
    flag_values = {
        ":source": "prebuilt",
    },
)

config_setting(
    name = "bootstrapped_toolchain",
    flag_values = {
        ":source": "bootstrapped",
    },
)

cc_args_list(
    name = "default_link_flags",
    args = select({
        "@platforms//os:macos": [
            "//toolchain/args/macos:default_link_flags",
        ],
        "@platforms//os:linux": [
            "//toolchain/args/linux:default_link_flags",
        ],
        "@platforms//os:windows": [],
        "@platforms//os:none": [],
    }),
)

cc_args_list(
    name = "default_startfiles",
    args = select({
        "@platforms//os:macos": [],
        "@platforms//os:linux": [
            "//toolchain/args:crt_search_directory",
        ],
        "@platforms//os:windows": [
            "//toolchain/args:crt_search_directory",
        ],
        "@platforms//os:none": [],
    }),
)

cc_args_list(
    name = "resource_dir",
    args = select({
        "@platforms//os:macos": [],
        "//conditions:default": [
            "//toolchain/args:resource_dir",
        ],
    }),
)

cc_args_list(
    name = "default_libs",
    args = select({
        "@platforms//os:macos": [
            "//toolchain/args/macos:default_libs",
        ],
        "@platforms//os:linux": [
            "//toolchain/args/linux:default_libs",
        ],
        "@platforms//os:windows": [
            "//toolchain/args/windows:default_libs",
        ],
        "//conditions:default": [],
    }),
)

# Those are stubs since we link against static_runtime_libs / dynamic_runtime_libs.
cc_args_list(
    name = "libcxx_library_search_paths",
    args = select({
        # libc++ is provided by the macOS SDK.
        "@platforms//os:macos": [],
        "@platforms//os:linux": [
            "//toolchain/args:libcxx_library_search_paths",
        ],
        "@platforms//os:windows": [
            "//toolchain/args:libcxx_library_search_paths",
        ],
        "//conditions:default": [],
    }),
)

# Those are stubs since we link against static_runtime_libs / dynamic_runtime_libs.
cc_args_list(
    name = "libunwind_library_search_paths",
    args = select({
        "@platforms//os:macos": [
            # We want to provide the stubs for macOS.
            "//toolchain/args:libunwind_library_search_paths",
        ],
        "@platforms//os:linux": [
            "//toolchain/args:libunwind_library_search_paths",
        ],
        "@platforms//os:windows": [
            "//toolchain/args:libunwind_library_search_paths",
        ],
        "//conditions:default": [],
    }),
)

cc_args_list(
    name = "sysroot_flags",
    args = select({
        "@platforms//os:macos": [
            "//toolchain/args/macos:macos_sdk_sysroot",
        ],
        "//conditions:default": [
            "//toolchain/args:empty_sysroot_flags",
        ],
    }),
)

cc_args_list(
    name = "hermetic_compile_flags",
    args = select({
        "@platforms//os:macos": [],
        "//conditions:default": [
            "//toolchain/args:hermetic_compile_flags",
        ],
    }),
)

cc_args_list(
    name = "stdlib",
    args = select({
        "@platforms//os:macos": [],
        "//conditions:default": [
            "//toolchain/args:stdlib",
        ],
    }),
)

# This makes the clang driver use compiler-rt compliant filenames
# and paths when resolving compiler runtime libraries from the resource-dir.
cc_args_list(
    name = "rtlib",
    args = [
        "//toolchain/args:rtlib_compiler_rt",
    ],
)

cc_args_list(
    name = "unwindlib",
    args = [
        "//toolchain/args:unwindlib_none",
    ],
)

# TODO(cerisier): extract those into proper semantic args list.
# TODO(zbarsky): This must match llvm/toolchains/llvm.bzl
cc_args_list(
    name = "macos_toolchain_args",
    args = [
        "//toolchain/args/macos:macos_minimum_os_flags",
    ],
)

# TODO(cerisier): extract those into proper semantic args list.
# TODO(zbarsky): This must match llvm/toolchains/llvm.bzl
cc_args_list(
    name = "linux_toolchain_args",
    args = [
        "//toolchain/args:libcxx_headers_include_search_paths",
    ] + select({
        "//platforms/config:musl": [
            "//toolchain/args/linux:kernel_headers_include_search_paths",
            "//toolchain/args/linux:musl_libc_headers_include_search_paths",
        ],
        "//platforms/config:gnu": [
            "//toolchain/args/linux:kernel_headers_include_search_paths",
            "//toolchain/args/linux:glibc_headers_include_search_paths",
        ],
        "//conditions:default": [],
    }) + select({
        "//platforms/config:musl": [
            #TODO: Handle musl dynamic linking
            # musl implies static linking for now
            "//toolchain/args:static_link_executable",
        ],
        "//conditions:default": [],
    }),
)

# TODO(cerisier): extract those into proper semantic args list.
# TODO(zbarsky): This must match llvm/toolchains/llvm.bzl
cc_args_list(
    name = "windows_toolchain_args",
    args = [
        "//toolchain/args:libcxx_headers_include_search_paths",
        "//toolchain/args/windows:mingw_headers_include_search_paths",
    ],
)

cc_args_list(
    name = "platform_specific_args",
    args = select({
        # Platform specific flags.
        "@platforms//os:macos": [":macos_toolchain_args"],
        "@platforms//os:linux": [":linux_toolchain_args"],
        "@platforms//os:windows": [":windows_toolchain_args"],
        "@platforms//os:none": [],
        "//conditions:default": [],
    }),
)

cc_args_list(
    name = "toolchain_args",
    args = [
        # Common default compile flags.
        "//toolchain/args:llvm_target_for_platform",
        "//toolchain/args:no_absolute_paths_for_builtins",
        "//toolchain/args:deterministic_compile_flags",
        "//toolchain/args:module_map",

        ":sysroot_flags",
        ":hermetic_compile_flags",

        # TODO(cerisier): Explode this into specific args instead
        ":platform_specific_args",

        # Optional sanitizers
        "//toolchain/args:ubsan_flags",

        # Common default link flags.
        "//toolchain/args:fuse_ld",
        ":libcxx_library_search_paths",
        ":libunwind_library_search_paths",
        ":rtlib",
        ":stdlib",
        ":unwindlib",
        ":resource_dir",
        ":default_link_flags",
        # Needs to stay out of resource_dir since clang does not always search for crtstuff for all targets.
        ":default_startfiles",
        ":default_libs",
    ],
)

cc_artifact_name_pattern(
    name = "windows_executable_pattern",
    category = "@rules_cc//cc/toolchains/artifacts:executable",
    prefix = "",
    extension = ".exe",
)

cc_action_type_set(
    name = "cpp_compile_actions_without_header_parsing",
    # See https://github.com/bazelbuild/rules_cc/blob/6dd2ef1fefbca004da449578c00d8ffb91a459ca/cc/toolchains/actions/BUILD#L224
    actions = [
        "@rules_cc//cc/toolchains/actions:linkstamp_compile",
        "@rules_cc//cc/toolchains/actions:cpp_compile",
        "@rules_cc//cc/toolchains/actions:cpp_module_compile",
        "@rules_cc//cc/toolchains/actions:cpp_module_codegen",
        "@rules_cc//cc/toolchains/actions:lto_backend",
        "@rules_cc//cc/toolchains/actions:clif_match",
        "@rules_cc//cc/toolchains/actions:objcpp_compile",
    ],
    visibility = ["//visibility:public"],
)

declare_toolchains()
declare_bootstrap_toolchains()

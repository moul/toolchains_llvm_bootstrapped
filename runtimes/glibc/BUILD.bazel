load("@bazel_lib//lib:copy_to_directory.bzl", "copy_to_directory")
load("@bazel_lib//lib:copy_file.bzl", "copy_file")
load("@bazel_skylib//rules:select_file.bzl", "select_file")
load("@bazel_skylib//rules:write_file.bzl", "write_file")
load("//toolchain:selects.bzl", "platform_extra_binary")
load(":glibc_linker_script.bzl", "make_glibc_linker_script")
load(":glibc_stubs_assembly_files.bzl", "glibc_stubs_assembly_files")
load(":glibc_shared_library.bzl", "make_glibc_shared_library")
load(":libc_aware_target_triple.bzl", "libc_aware_target_triple")

# Generate all support libraries unconditionally.
#
# The stubs generator creates empty .s files for libraries not provided by the
# target glibc version, which is simpler than selecting which libraries to
# generate based on that target glibc version.
LIBC_SO_VERSIONS = {
    "ld": "2",
    "c": "6",
    "dl": "2",
    "m": "6",
    "pthread": "0",
    "resolv": "2",
    "rt": "1",
    "util": "1",
}

alias(
    name = "glibc-stubs-generator",
    actual = platform_extra_binary("bin/glibc-stubs-generator"),
)

# Generate assembly files for the glibc (one per lib)
glibc_stubs_assembly_files(
    name = "generate_glibc_stubs",
    target = libc_aware_target_triple(),
    abilist = "abilists",
    visibility = ["//visibility:public"],
)

# Make one target per lib assembly file
[
    select_file(
        name = "lib" + lib + ".s",
        srcs = ":generate_glibc_stubs",
        subpath = "glibc/build/" + lib + ".s",
        visibility = ["//visibility:public"],
    ) for lib in LIBC_SO_VERSIONS.keys()
]

select_file(
    name = "all.map",
    srcs = ":generate_glibc_stubs",
    subpath = "glibc/build/all.map",
    visibility = ["//visibility:public"],
)

# The below are global symbols that are provided and initialized by the dynamic
# linker (ld.so) when using glibc.
#
# To avoid having to compute the proper ld.so name in the linker script, we
# resort to providing those symbols here.
#
# These symbols may not be normally available for all targets and versions of the
# glibc but it should be "mostly" harmless.
#
# It might cause faulty programs to successfully link when they should not, even
# tho the situations should be very rare or non-existent in practice.
write_file(
    name = "__stack_chk_guard.S",
    out = "glibc/build/__stack_chk_guard.S",
    content = [
        ".globl __stack_chk_guard",
        ".type __stack_chk_guard, %object;",
        # TODO: Support 32 bit architectures,
        #      Infer this from the target.
        "#if __SIZEOF_POINTER__ == 4",
        ".size __stack_chk_guard, 4",
        "#else",
        ".size __stack_chk_guard, 8",
        "#endif",
        # Will be relocated at runtime by the dynamic linker itself.
        "__stack_chk_guard:",
    ],
)

# Same as above.
write_file(
    name = "__tls_get_addr.S",
    out = "glibc/build/__tls_get_addr.S",
    content = [
        "#if __SIZEOF_POINTER__ == 4",
        ".balign 4",
        "#else",
        ".balign 8",
        "#endif",
        ".globl __tls_get_addr",
        ".type __tls_get_addr, %function;",
        "#if __SIZEOF_POINTER__ == 4",
        "__tls_get_addr: .long 0",
        "#else",
        "__tls_get_addr: .quad 0",
        "#endif",
    ],
)

# Make one cc_shared_library target per lib, using the assembly file
LIBS = [
    make_glibc_shared_library(
        name = "lib%s_shared_library" % lib,
        lib_name = lib,
        lib_version = version,
        srcs = [":lib" + lib + ".s"],
    ) for (lib, version) in LIBC_SO_VERSIONS.items() if lib != "c"
] + [
    make_glibc_shared_library(
        name = "libc_shared_library",
        lib_name = "c",
        lib_version = "6",
        srcs = [
            ":libc.s",
            ":__stack_chk_guard.S",
            ":__tls_get_addr.S",
        ],
        extra_link_flags = [
            # _IO_stdin_used is defined as a global symbol in .rodata
            # and needs to be relocated at runtime with values from the CRTs.
            "-z",
            "notext",
        ],
    ),
]

# The below creates linker scripts with the names that the linker wants
# (libc.so, libdl.so) which redirect to libc.so.6, libdl.so.2, etc.
LINKER_SCRIPTS = [
    make_glibc_linker_script(
        name = "lib%s_linker_script" % lib,
        lib_name = lib,
        lib_version = version,
        additional_linker_inputs = [
            # we make it available in the search directory sibling to the libc.so
            "libc_nonshared.a",
        ] if lib == "c" else [],
    ) for (lib, version) in LIBC_SO_VERSIONS.items()
]

copy_file(
    name = "glibc_libc_nonshared.static",
    src = "@glibc//:glibc_c_nonshared.static",
    out = "libc_nonshared.a",
    allow_symlink = True,
)

# In newer versions of glibc various libs such as libm, librt are
# normally included in libc and not available as separate libraries.
#
# But in the way we handle generating libc stubs, we chose to generate
# empty libs for those that have been removed so that we do not have to
# handle varying inclusions.
copy_to_directory(
    name = "glibc_library_search_directory",
    srcs = LIBS + LINKER_SCRIPTS + [
        "libc_nonshared.a",
    ],
    visibility = ["//visibility:public"],
)

alias(
    name = "glibc_headers_include_search_directory",
    actual = "@glibc//:glibc_headers_directory",
    visibility = ["//visibility:public"],
)

alias(
    name = "glibc_Scrt1.object",
    actual = "@glibc//:glibc_Scrt1.object",
    visibility = ["//visibility:public"],
)

alias(
    name = "glibc_crt1.object",
    actual = "@glibc//:glibc_crt1.object",
    visibility = ["//visibility:public"],
)

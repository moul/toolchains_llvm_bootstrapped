commit eca538050f123fe81d9cb9e9a3c902bf29d0c5d7
Author: David Zbarsky <dzbarsky@gmail.com>
Date:   Wed Feb 11 07:54:34 2026 -0500

    bootstrap

diff --git a/.bazelrc b/.bazelrc
index 5c76be5a..d4cf6028 100644
--- a/.bazelrc
+++ b/.bazelrc
@@ -33,6 +33,8 @@ build:ci --spawn_strategy=standalone
 build:ci --genrule_strategy=standalone
 test:ci --test_strategy=standalone
 
+common:bootstrap --@io_bazel_rules_go//go/toolchain:source=bootstrapped
+
 # Incompatible flags to test in a dedicated CI pipeline.
 build:incompatible --incompatible_load_proto_rules_from_bzl
 build:incompatible --incompatible_enable_cc_toolchain_resolution
diff --git a/MODULE.bazel b/MODULE.bazel
index 38438955..733015b7 100644
--- a/MODULE.bazel
+++ b/MODULE.bazel
@@ -22,8 +22,13 @@ go_sdk.from_file(
     name = "go_default_sdk",
     go_mod = "//:go.mod",
 )
+go_sdk.bootstrap(
+    name = "go_bootstrap_sdk",
+    go_mod = "//:go.mod",
+)
 use_repo(
     go_sdk,
+    "go_bootstrap_sdk",
     "go_host_compatible_sdk_label",
     "go_toolchains",
     # This name is ugly on purpose to avoid a conflict with a user-named SDK.
diff --git a/go/private/BUILD.bootstrap.sdk.bazel b/go/private/BUILD.bootstrap.sdk.bazel
new file mode 100644
index 00000000..a639ffbe
--- /dev/null
+++ b/go/private/BUILD.bootstrap.sdk.bazel
@@ -0,0 +1,121 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_sdk")
+load("@io_bazel_rules_go//go/private:common.bzl", "RULES_GO_STDLIB_PREFIX")
+load("@io_bazel_rules_go//go/private:go_toolchain.bzl", "declare_go_toolchains")
+load("@io_bazel_rules_go//go/private:sdk_build_defs.bzl", "STDLIB_SRCS_EXCLUDE")
+load("@io_bazel_rules_go//go/private/rules:binary.bzl", "go_tool_binary")
+load("@io_bazel_rules_go//go/private/rules:sdk.bzl", "bootstrap_go_sdk", "package_list")
+load("@io_bazel_rules_go//go/private/rules:transition.bzl", "non_go_reset_target")
+
+package(default_visibility = ["//visibility:public"])
+
+bootstrap_go_sdk(
+    name = "bootstrap",
+    experiments = {experiments},
+    goarch = "{goarch}",
+    goos = "{goos}",
+)
+
+filegroup(
+    name = "libs",
+    # Go 1.20+ no longer ships precompiled stdlib .a files in pkg/{goos}_{goarch}.
+    # Keep this empty so rules_go always compiles stdlib from source for the bootstrapped SDK.
+    srcs = [],
+)
+
+filegroup(
+    name = "headers",
+    srcs = [":bootstrap_headers"],
+)
+
+filegroup(
+    name = "srcs",
+    srcs = [":bootstrap_srcs"],
+)
+
+filegroup(
+    name = "compiler_binaries",
+    srcs = [":bootstrap_compiler_binaries"],
+)
+
+filegroup(
+    name = "tools",
+    srcs = [":bootstrap_tools"],
+)
+
+filegroup(
+    name = "config",
+    srcs = [":bootstrap_config"],
+)
+
+go_sdk(
+    name = "go_sdk",
+    srcs = [":srcs"],
+    experiments = {experiments},
+    go = ":bootstrap_go",
+    goarch = "{goarch}",
+    goos = "{goos}",
+    headers = [":headers"],
+    libs = [":libs"],
+    package_list = ":package_list",
+    root_file = ":bootstrap_root_file",
+    tools = [":tools"],
+    version = "{version}",
+)
+
+go_tool_binary(
+    name = "builder",
+    srcs = ["@io_bazel_rules_go//go/tools/builders:builder_srcs"],
+    exec_compatible_with = {exec_compatible_with},
+    ldflags = "-X main.rulesGoStdlibPrefix={}".format(RULES_GO_STDLIB_PREFIX),
+    # The .exe suffix is required on Windows and harmless on other platforms.
+    # Output attributes are not configurable, so we use it everywhere.
+    out_pack = "pack.exe",
+    sdk = ":go_sdk",
+)
+
+non_go_reset_target(
+    name = "builder_reset",
+    dep = ":builder",
+)
+
+non_go_reset_target(
+    name = "pack_reset",
+    dep = ":pack.exe",
+)
+
+# TODO(jayconrod): Gazelle depends on this file directly. This dependency
+# should be broken, and this rule should be folded into go_sdk.
+package_list(
+    name = "package_list",
+    srcs = glob(
+        ["src/**/*"],
+        allow_empty = True,
+        exclude = STDLIB_SRCS_EXCLUDE,
+    ),
+    out = "packages.txt",
+    root_file = "ROOT",
+)
+
+declare_go_toolchains(
+    builder = ":builder_reset",
+    exec_goos = "{goos}",
+    pack = ":pack_reset",
+    sdk = ":go_sdk",
+)
+
+filegroup(
+    name = "files",
+    srcs = [":bootstrap_files"],
+)
+
+exports_files(
+    glob([
+        "lib/time/zoneinfo.zip",
+        # wasm support files including wasm_exec.js
+        # for GOOS=js GOARCH=wasm
+        # located in misc/wasm/ (Go 1.23 and earlier)
+        # or lib/wasm/ (Go 1.24 and later)
+        "*/wasm/**",
+    ]),
+    visibility = ["//visibility:public"],
+)
diff --git a/go/private/BUILD.sdk.bazel b/go/private/BUILD.sdk.bazel
index ffaf4e53..24b921a8 100644
--- a/go/private/BUILD.sdk.bazel
+++ b/go/private/BUILD.sdk.bazel
@@ -1,6 +1,7 @@
 load("@io_bazel_rules_go//go:def.bzl", "go_sdk")
 load("@io_bazel_rules_go//go/private:common.bzl", "RULES_GO_STDLIB_PREFIX")
 load("@io_bazel_rules_go//go/private:go_toolchain.bzl", "declare_go_toolchains")
+load("@io_bazel_rules_go//go/private:sdk_build_defs.bzl", "STDLIB_SRCS_EXCLUDE")
 load("@io_bazel_rules_go//go/private/rules:binary.bzl", "go_tool_binary")
 load("@io_bazel_rules_go//go/private/rules:sdk.bzl", "package_list")
 load("@io_bazel_rules_go//go/private/rules:transition.bzl", "non_go_reset_target")
@@ -26,21 +27,7 @@ filegroup(
     srcs = glob(
         ["src/**/*"],
         allow_empty = True,
-        exclude = [
-            "src/**/*_test.go",
-            "src/**/testdata/**",
-            # Only used by tests, cgo fails with linux before 3.17
-            "src/crypto/internal/sysrand/internal/seccomp/**",
-            "src/encoding/json/internal/jsontest/**",
-            "src/log/slog/internal/benchmarks/**",
-            "src/log/slog/internal/slogtest/**",
-            "src/internal/obscuretestdata/**",
-            "src/internal/testpty/**",
-            "src/net/internal/cgotest/**",
-            "src/net/internal/socktest/**",
-            "src/reflect/internal/example*/**",
-            "src/runtime/internal/startlinetest/**",
-        ],
+        exclude = STDLIB_SRCS_EXCLUDE,
     ),
 )
 
@@ -54,6 +41,20 @@ filegroup(
     ],
 )
 
+filegroup(
+    name = "compiler_binaries",
+    srcs = glob(
+        [
+            "pkg/tool/{goos}_{goarch}/asm*",
+            "pkg/tool/{goos}_{goarch}/cgo*",
+            "pkg/tool/{goos}_{goarch}/compile*",
+            "pkg/tool/{goos}_{goarch}/cover*",
+            "pkg/tool/{goos}_{goarch}/link*",
+        ],
+        allow_empty = True,
+    ),
+)
+
 filegroup(
     name = "config",
     srcs = glob(
diff --git a/go/private/extensions.bzl b/go/private/extensions.bzl
index 5dccc871..2c9f1e65 100644
--- a/go/private/extensions.bzl
+++ b/go/private/extensions.bzl
@@ -15,7 +15,7 @@
 load("@io_bazel_rules_go_bazel_features//:features.bzl", "bazel_features")
 load("//go/private:go_mod.bzl", "version_from_go_mod")
 load("//go/private:nogo.bzl", "DEFAULT_NOGO", "NOGO_DEFAULT_EXCLUDES", "NOGO_DEFAULT_INCLUDES", "go_register_nogo")
-load("//go/private:sdk.bzl", "detect_host_platform", "fetch_sdks_by_version", "go_download_sdk_rule", "go_host_sdk_rule", "go_multiple_toolchains", "go_wrap_sdk_rule")
+load("//go/private:sdk.bzl", "detect_host_platform", "fetch_sdks_by_version", "go_download_bootstrap_sdk_rule", "go_download_sdk_rule", "go_host_sdk_rule", "go_multiple_toolchains", "go_wrap_sdk_rule")
 
 def host_compatible_toolchain_impl(ctx):
     ctx.file("BUILD.bazel")
@@ -62,6 +62,17 @@ _download_tag = tag_class(
     },
 )
 
+_bootstrap_tag = tag_class(
+    doc = """Download a Go SDK source archive and bootstrap tool binaries from source in pure mode (CGO disabled). Optionally apply local customisations by applying patches and setting experiments.""",
+    attrs = _COMMON_TAG_ATTRS | {
+        "bootstrap_strip_prefix": attr.string(default = "go"),
+        "go_mod": attr.label(
+            doc = "The go.mod file to read the SDK version from.",
+        ),
+        "version": attr.string(),
+    },
+)
+
 _host_tag = tag_class(
     attrs = {
         "name": attr.string(),
@@ -191,7 +202,7 @@ def _go_sdk_impl(ctx):
         else:
             multi_version_module[module.name] = False
 
-    # We remember the first host compatible toolchain declared by the download, host, and from_file tags.
+    # We remember the first host compatible toolchain declared by the download, bootstrap, host, and from_file tags.
     # The order follows bazel's iteration over modules (the toolchains declared by the root module are considered first).
     # We know that at least `go_default_sdk` (which is declared by the `rules_go` module itself) is host compatible.
     first_host_compatible_toolchain = None
@@ -252,6 +263,7 @@ def _go_sdk_impl(ctx):
                 sdk_repo = name,
                 sdk_type = "remote",
                 sdk_version = wrap_tag.version,
+                sdk_source = "prebuilt",
             ))
             if (not wrap_tag.goos or wrap_tag.goos == host_detected_goos) and (not wrap_tag.goarch or wrap_tag.goarch == host_detected_goarch):
                 first_host_compatible_toolchain = first_host_compatible_toolchain or "@{}//:ROOT".format(name)
@@ -316,6 +328,7 @@ def _go_sdk_impl(ctx):
                 sdk_repo = name,
                 sdk_type = "remote",
                 sdk_version = download_tag.version,
+                sdk_source = "prebuilt",
             ))
 
             # Additionally register SDKs for all common execution platforms, but only if the user
@@ -352,8 +365,55 @@ def _go_sdk_impl(ctx):
                         sdk_repo = default_name,
                         sdk_type = "remote",
                         sdk_version = download_tag.version,
+                        sdk_source = "prebuilt",
                     ))
 
+        for index, bootstrap_tag in enumerate(module.tags.bootstrap):
+            # SDKs without an explicit version are fetched even when not selected by toolchain
+            # resolution. This is acceptable if brought in by the root module, but transitive
+            # dependencies should not slow down the build in this way.
+            if not module.is_root and not bootstrap_tag.version and not bootstrap_tag.go_mod:
+                fail("go_sdk.bootstrap: version or go_mod must be specified in non-root module " + module.name)
+
+            # SDKs with an explicit name are at risk of colliding with those from other modules.
+            if (not module.is_root and not module.name == "rules_go") and bootstrap_tag.name:
+                fail("go_sdk.bootstrap: name must not be specified in non-root module " + module.name)
+
+            if bootstrap_tag.version and bootstrap_tag.go_mod:
+                fail("go_sdk.bootstrap: version and go_mod cannot both be set")
+
+            version = bootstrap_tag.version or (version_from_go_mod(ctx, bootstrap_tag.go_mod) if bootstrap_tag.go_mod else "")
+            if not version:
+                fail("go_sdk.bootstrap: version or go_mod must be set")
+
+            name = bootstrap_tag.name or _default_go_sdk_name(
+                module = module,
+                multi_version = multi_version_module[module.name],
+                tag_type = "bootstrap",
+                index = index,
+            )
+
+            _download_bootstrap_sdk(
+                get_sdks_by_version = get_sdks_by_version_cached,
+                name = name,
+                goos = bootstrap_tag.goos,
+                goarch = bootstrap_tag.goarch,
+                bootstrap_tag = bootstrap_tag,
+                version = version,
+            )
+
+            if (not bootstrap_tag.goos or bootstrap_tag.goos == host_detected_goos) and (not bootstrap_tag.goarch or bootstrap_tag.goarch == host_detected_goarch):
+                first_host_compatible_toolchain = first_host_compatible_toolchain or "@{}//:ROOT".format(name)
+
+            toolchains.append(struct(
+                goos = bootstrap_tag.goos,
+                goarch = bootstrap_tag.goarch,
+                sdk_repo = name,
+                sdk_type = "remote",
+                sdk_version = version,
+                sdk_source = "bootstrapped",
+            ))
+
         for index, host_tag in enumerate(module.tags.host):
             # Dependencies can rely on rules_go providing a default remote SDK. They can also
             # configure a specific version of the SDK to use. However, they should not add a
@@ -379,6 +439,7 @@ def _go_sdk_impl(ctx):
                 sdk_repo = name,
                 sdk_type = "host",
                 sdk_version = host_tag.version,
+                sdk_source = "prebuilt",
             ))
             first_host_compatible_toolchain = first_host_compatible_toolchain or "@{}//:ROOT".format(name)
 
@@ -402,6 +463,7 @@ def _go_sdk_impl(ctx):
         sdk_repos = [toolchain.sdk_repo for toolchain in toolchains],
         sdk_types = [toolchain.sdk_type for toolchain in toolchains],
         sdk_versions = [toolchain.sdk_version for toolchain in toolchains],
+        sdk_sources = [toolchain.sdk_source for toolchain in toolchains],
     )
 
     if bazel_features.external_deps.extension_metadata_has_reproducible:
@@ -461,6 +523,25 @@ def _download_sdk(*, get_sdks_by_version, name, goos, goarch, download_tag):
         strip_prefix = download_tag.strip_prefix,
     )
 
+def _download_bootstrap_sdk(*, get_sdks_by_version, name, goos, goarch, bootstrap_tag, version):
+    sdks = bootstrap_tag.sdks
+    if version and not sdks:
+        sdks = get_sdks_by_version(version)
+
+    go_download_bootstrap_sdk_rule(
+        name = name,
+        goos = goos,
+        goarch = goarch,
+        sdks = sdks,
+        experiments = bootstrap_tag.experiments,
+        patches = bootstrap_tag.patches,
+        patch_strip = bootstrap_tag.patch_strip,
+        urls = bootstrap_tag.urls,
+        version = version,
+        strip_prefix = bootstrap_tag.strip_prefix,
+        bootstrap_strip_prefix = bootstrap_tag.bootstrap_strip_prefix,
+    )
+
 go_sdk_extra_kwargs = {
     # The choice of a host-compatible SDK is expressed in repository rule attribute values and
     # depends on host OS and architecture.
@@ -472,6 +553,7 @@ go_sdk = module_extension(
     implementation = _go_sdk_impl,
     tag_classes = {
         "download": _download_tag,
+        "bootstrap": _bootstrap_tag,
         "host": _host_tag,
         "nogo": _nogo_tag,
         "wrap": _wrap_tag,
diff --git a/go/private/go_toolchain.bzl b/go/private/go_toolchain.bzl
index e5619f9e..2f096c0f 100644
--- a/go/private/go_toolchain.bzl
+++ b/go/private/go_toolchain.bzl
@@ -136,6 +136,7 @@ def declare_bazel_toolchains(
         prerelease,
         sdk_name,
         sdk_type,
+        sdk_source = "prebuilt",
         prefix = ""):
     """Declares toolchain targets for each platform."""
 
@@ -242,6 +243,33 @@ def declare_bazel_toolchains(
         visibility = ["//visibility:private"],
     )
 
+    sdk_source_label = Label("//go/toolchain:source")
+
+    native.config_setting(
+        name = prefix + "match_sdk_source",
+        flag_values = {
+            sdk_source_label: sdk_source,
+        },
+        visibility = ["//visibility:private"],
+    )
+
+    native.config_setting(
+        name = prefix + "match_all_sources",
+        flag_values = {
+            sdk_source_label: "",
+        },
+        visibility = ["//visibility:private"],
+    )
+
+    selects.config_setting_group(
+        name = prefix + "sdk_source_setting",
+        match_any = [
+            ":" + prefix + "match_all_sources",
+            ":" + prefix + "match_sdk_source",
+        ],
+        visibility = ["//visibility:private"],
+    )
+
     for p in PLATFORMS:
         if p.cgo:
             # Don't declare separate toolchains for cgo_on / cgo_off.
@@ -266,6 +294,7 @@ def declare_bazel_toolchains(
             target_compatible_with = constraints,
             target_settings = [
                 ":" + prefix + "sdk_name_setting",
+                ":" + prefix + "sdk_source_setting",
                 ":" + prefix + "sdk_version_setting",
             ],
             toolchain = go_toolchain_repo + "//:go_" + p.name + "-impl",
diff --git a/go/private/rules/sdk.bzl b/go/private/rules/sdk.bzl
index 7d7d7b45..e0a2f5e6 100644
--- a/go/private/rules/sdk.bzl
+++ b/go/private/rules/sdk.bzl
@@ -149,3 +149,291 @@ def _build_package_list(ctx, srcs, root_file, out):
         packages[pkg_name] = None
     content = "\n".join(sorted(packages.keys())) + "\n"
     ctx.actions.write(out, content)
+
+def _bootstrap_go_sdk_impl(ctx):
+    windows_constraint = ctx.attr._windows_constraint[platform_common.ConstraintValueInfo]
+    is_windows_exec = ctx.target_platform_has_constraint(windows_constraint)
+    sh_toolchain = ctx.toolchains["@rules_shell//shell:toolchain_type"]
+    if not sh_toolchain or not sh_toolchain.path:
+        fail("Go bootstrap SDK requires @rules_shell//shell:toolchain_type with a configured shell path")
+
+    root_file = ctx.actions.declare_file(ctx.label.name + "/ROOT")
+    version = ctx.actions.declare_file(ctx.label.name + "/VERSION")
+    go_env = ctx.actions.declare_file(ctx.label.name + "/go.env")
+    go = ctx.actions.declare_file(ctx.label.name + "/bin/go" + (".exe" if ctx.attr.goos == "windows" else ""))
+    gofmt = ctx.actions.declare_file(ctx.label.name + "/bin/gofmt" + (".exe" if ctx.attr.goos == "windows" else ""))
+
+    srcs = ctx.actions.declare_directory(ctx.label.name + "/src")
+    libs = ctx.actions.declare_directory(ctx.label.name + "/pkg/" + ctx.attr.goos + "_" + ctx.attr.goarch)
+    headers = ctx.actions.declare_directory(ctx.label.name + "/pkg/include")
+    tools = ctx.actions.declare_directory(ctx.label.name + "/pkg/tool/" + ctx.attr.goos + "_" + ctx.attr.goarch)
+    lib_misc = ctx.actions.declare_directory(ctx.label.name + "/lib")
+    bootstrap_script = ctx.actions.declare_file(ctx.label.name + "_bootstrap_sdk.sh")
+
+    args = ctx.actions.args()
+    args.add(bootstrap_script)
+    args.add(ctx.file.make_bash)
+    args.add(ctx.file.make_bat)
+    args.add(ctx.file.bootstrap_go)
+    args.add(root_file)
+    args.add(version)
+    args.add(go_env)
+    args.add(go)
+    args.add(gofmt)
+    args.add_all([srcs], expand_directories = False)
+    args.add_all([libs], expand_directories = False)
+    args.add_all([headers], expand_directories = False)
+    args.add_all([tools], expand_directories = False)
+    args.add_all([lib_misc], expand_directories = False)
+    args.add(",".join(ctx.attr.experiments))
+    args.add(ctx.attr.goos + "_" + ctx.attr.goarch)
+    args.add("1" if is_windows_exec else "0")
+
+    ctx.actions.write(
+        output = bootstrap_script,
+        content = """set -euo pipefail
+
+MAKE_BASH="$1"
+MAKE_BAT="$2"
+BOOTSTRAP_GO="$3"
+ROOT_FILE="$4"
+VERSION_FILE="$5"
+GO_ENV_FILE="$6"
+GO_BIN="$7"
+GOFMT_BIN="$8"
+SRCS_OUT="$9"
+LIBS_OUT="${10}"
+HEADERS_OUT="${11}"
+TOOLS_OUT="${12}"
+LIB_OUT="${13}"
+EXPERIMENTS="${14}"
+GOOS_GOARCH="${15}"
+IS_WINDOWS="${16}"
+
+SRC_ROOT="$(cd "$(dirname "$MAKE_BASH")/.." && pwd)"
+BOOTSTRAP_ROOT="$(cd "$(dirname "$BOOTSTRAP_GO")/.." && pwd)"
+WORKDIR="${PWD}/_bootstrap_sdk_workdir_${RANDOM}_${RANDOM}"
+ACTION_PATH="${PATH:-}"
+if [[ -z "$ACTION_PATH" ]]; then
+  ACTION_PATH="/usr/bin:/bin:/usr/sbin:/sbin"
+fi
+
+copy_dir() {
+  local src="$1"
+  local dst="$2"
+  rm -rf "$dst"
+  mkdir -p "$dst"
+  if [[ -d "$src" ]]; then
+    cp -RL "$src"/. "$dst"
+  fi
+}
+
+rm -rf "$WORKDIR"
+mkdir -p "$WORKDIR/goroot"
+cp -RL "$SRC_ROOT"/. "$WORKDIR/goroot"
+mkdir -p "$WORKDIR/home" "$WORKDIR/gocache"
+
+(
+  cd "$WORKDIR/goroot/src"
+  if [[ "$IS_WINDOWS" == "1" ]]; then
+    HOME="$WORKDIR/home" \
+    GOCACHE="$WORKDIR/gocache" \
+    PATH="$ACTION_PATH" \
+    CGO_ENABLED=0 \
+    GO111MODULE=off \
+    GOENV=off \
+    GOTELEMETRY=off \
+    GOTOOLCHAIN=local \
+    GOROOT_BOOTSTRAP="$BOOTSTRAP_ROOT" \
+    GOEXPERIMENT="$EXPERIMENTS" \
+    cmd.exe /c "$(basename "$MAKE_BAT")"
+  else
+    HOME="$WORKDIR/home" \
+    GOCACHE="$WORKDIR/gocache" \
+    PATH="$ACTION_PATH" \
+    CGO_ENABLED=0 \
+    GO111MODULE=off \
+    GOENV=off \
+    GOTELEMETRY=off \
+    GOTOOLCHAIN=local \
+    GOROOT_BOOTSTRAP="$BOOTSTRAP_ROOT" \
+    GOEXPERIMENT="$EXPERIMENTS" \
+    ./make.bash
+  fi
+)
+
+mkdir -p "$(dirname "$ROOT_FILE")" "$(dirname "$GO_BIN")" "$(dirname "$GOFMT_BIN")"
+: > "$ROOT_FILE"
+cp "$WORKDIR/goroot/VERSION" "$VERSION_FILE"
+if [[ -f "$WORKDIR/goroot/go.env" ]]; then
+  cp "$WORKDIR/goroot/go.env" "$GO_ENV_FILE"
+else
+  : > "$GO_ENV_FILE"
+fi
+cp "$WORKDIR/goroot/bin/$(basename "$GO_BIN")" "$GO_BIN"
+cp "$WORKDIR/goroot/bin/$(basename "$GOFMT_BIN")" "$GOFMT_BIN"
+
+copy_dir "$WORKDIR/goroot/src" "$SRCS_OUT"
+copy_dir "$WORKDIR/goroot/pkg/$GOOS_GOARCH" "$LIBS_OUT"
+copy_dir "$WORKDIR/goroot/pkg/include" "$HEADERS_OUT"
+copy_dir "$WORKDIR/goroot/pkg/tool/$GOOS_GOARCH" "$TOOLS_OUT"
+copy_dir "$WORKDIR/goroot/lib" "$LIB_OUT"
+
+rm -rf "$WORKDIR"
+""",
+    )
+
+    ctx.actions.run(
+        executable = sh_toolchain.path,
+        inputs = depset(
+            ctx.files.srcs +
+            ctx.files.bootstrap_srcs +
+            [bootstrap_script, ctx.file.make_bash, ctx.file.make_bat, ctx.file.bootstrap_go],
+        ),
+        outputs = [
+            root_file,
+            version,
+            go_env,
+            go,
+            gofmt,
+            srcs,
+            libs,
+            headers,
+            tools,
+            lib_misc,
+        ],
+        arguments = [args],
+        toolchain = "@rules_shell//shell:toolchain_type",
+        mnemonic = "GoBootstrapSDK",
+        progress_message = "Bootstrapping Go SDK from source",
+    )
+
+    return [
+        DefaultInfo(
+            files = depset([go]),
+            executable = go,
+        ),
+        OutputGroupInfo(
+            root_file = depset([root_file]),
+            version = depset([version]),
+            go = depset([go]),
+            config = depset([go_env]),
+            srcs = depset([srcs]),
+            libs = depset([libs]),
+            headers = depset([headers]),
+            compiler_binaries = depset([tools]),
+            tools = depset([tools, gofmt, go_env]),
+            files = depset([go, gofmt, version, go_env, root_file, srcs, libs, headers, tools, lib_misc]),
+        ),
+    ]
+
+_bootstrap_go_sdk = rule(
+    implementation = _bootstrap_go_sdk_impl,
+    attrs = {
+        "srcs": attr.label_list(
+            allow_files = True,
+            mandatory = True,
+        ),
+        "bootstrap_srcs": attr.label_list(
+            allow_files = True,
+            mandatory = True,
+        ),
+        "make_bash": attr.label(
+            allow_single_file = True,
+            mandatory = True,
+        ),
+        "make_bat": attr.label(
+            allow_single_file = True,
+            mandatory = True,
+        ),
+        "bootstrap_go": attr.label(
+            allow_single_file = True,
+            mandatory = True,
+        ),
+        "goos": attr.string(mandatory = True),
+        "goarch": attr.string(mandatory = True),
+        "experiments": attr.string_list(),
+        "_windows_constraint": attr.label(
+            default = "@platforms//os:windows",
+        ),
+    },
+    executable = True,
+    toolchains = [
+        config_common.toolchain_type("@rules_shell//shell:toolchain_type"),
+    ],
+)
+
+def bootstrap_go_sdk(name, goos, goarch, experiments):
+    impl_name = name + "_impl"
+
+    _bootstrap_go_sdk(
+        name = impl_name,
+        srcs = native.glob(
+            ["**"],
+            exclude = [
+                "_bootstrap_sdk/**",
+                "BUILD.bazel",
+                "version.bzl",
+            ],
+        ),
+        bootstrap_srcs = native.glob(["_bootstrap_sdk/**"]),
+        make_bash = "src/make.bash",
+        make_bat = "src/make.bat",
+        bootstrap_go = "_bootstrap_sdk/bin/go" + (".exe" if goos == "windows" else ""),
+        goos = goos,
+        goarch = goarch,
+        experiments = experiments,
+    )
+
+    native.alias(
+        name = name + "_go",
+        actual = ":" + impl_name,
+    )
+
+    native.filegroup(
+        name = name + "_root_file",
+        srcs = [":" + impl_name],
+        output_group = "root_file",
+    )
+
+    native.filegroup(
+        name = name + "_config",
+        srcs = [":" + impl_name],
+        output_group = "config",
+    )
+
+    native.filegroup(
+        name = name + "_srcs",
+        srcs = [":" + impl_name],
+        output_group = "srcs",
+    )
+
+    native.filegroup(
+        name = name + "_libs",
+        srcs = [":" + impl_name],
+        output_group = "libs",
+    )
+
+    native.filegroup(
+        name = name + "_headers",
+        srcs = [":" + impl_name],
+        output_group = "headers",
+    )
+
+    native.filegroup(
+        name = name + "_tools",
+        srcs = [":" + impl_name],
+        output_group = "tools",
+    )
+
+    native.filegroup(
+        name = name + "_compiler_binaries",
+        srcs = [":" + impl_name],
+        output_group = "compiler_binaries",
+    )
+
+    native.filegroup(
+        name = name + "_files",
+        srcs = [":" + impl_name],
+        output_group = "files",
+    )
diff --git a/go/private/sdk.bzl b/go/private/sdk.bzl
index a5deab41..9cdb0720 100644
--- a/go/private/sdk.bzl
+++ b/go/private/sdk.bzl
@@ -152,6 +152,120 @@ go_download_sdk_rule = repository_rule(
     },
 )
 
+def _go_download_bootstrap_sdk_impl(ctx):
+    host_goos, host_goarch = detect_host_platform(ctx)
+    if not ctx.attr.goos and not ctx.attr.goarch:
+        goos, goarch = host_goos, host_goarch
+    else:
+        if not ctx.attr.goos:
+            fail("goarch set but goos not set")
+        if not ctx.attr.goarch:
+            fail("goos set but goarch not set")
+        goos, goarch = ctx.attr.goos, ctx.attr.goarch
+
+    platform = goos + "_" + goarch
+    version = ctx.attr.version
+    sdks = ctx.attr.sdks
+
+    if not version:
+        if ctx.attr.patches:
+            fail("a single version must be specified to apply patches")
+
+    if not sdks:
+        if not version:
+            ctx.report_progress("Finding latest Go version")
+        else:
+            ctx.report_progress("Finding Go SHA-256 sums")
+        sdks_by_version = fetch_sdks_by_version(ctx)
+
+        if not version:
+            highest_version = None
+            for v in sdks_by_version.keys():
+                pv = parse_version(v)
+                if not pv or _version_is_prerelease(pv):
+                    # skip parse errors and pre-release versions
+                    continue
+                if not highest_version or _version_less(highest_version, pv):
+                    highest_version = pv
+            if not highest_version:
+                fail("did not find any Go versions in https://go.dev/dl/?mode=json")
+            version = _version_string(highest_version)
+        if version not in sdks_by_version:
+            fail("did not find version {} in https://go.dev/dl/?mode=json".format(version))
+        sdks = sdks_by_version[version]
+
+    if platform not in sdks:
+        fail("unsupported platform {}".format(platform))
+    if "source" not in sdks:
+        fail("version {} does not contain a source SDK archive in https://go.dev/dl/?mode=json".format(version))
+
+    source_filename, source_sha256 = sdks["source"]
+    bootstrap_filename, bootstrap_sha256 = sdks[platform]
+    _remote_sdk(
+        ctx,
+        [url.format(source_filename) for url in ctx.attr.urls],
+        ctx.attr.strip_prefix,
+        source_sha256,
+    )
+    patch(ctx, patch_args = _get_patch_args(ctx.attr.patch_strip))
+
+    _download_bootstrap_sdk(
+        ctx,
+        urls = [url.format(bootstrap_filename) for url in ctx.attr.urls],
+        strip_prefix = ctx.attr.bootstrap_strip_prefix,
+        sha256 = bootstrap_sha256,
+    )
+
+    detected_version = _detect_sdk_version(ctx, ".")
+    _sdk_build_file(ctx, platform, detected_version, experiments = ctx.attr.experiments)
+
+    if not ctx.attr.sdks and not ctx.attr.version:
+        # Returning this makes Bazel print a message that 'version' must be
+        # specified for a reproducible build.
+        return {
+            "name": ctx.attr.name,
+            "goos": ctx.attr.goos,
+            "goarch": ctx.attr.goarch,
+            "sdks": ctx.attr.sdks,
+            "urls": ctx.attr.urls,
+            "version": version,
+            "strip_prefix": ctx.attr.strip_prefix,
+        }
+
+    if hasattr(ctx, "repo_metadata"):
+        return ctx.repo_metadata(reproducible = True)
+    else:
+        return None
+
+go_download_bootstrap_sdk_rule = repository_rule(
+    implementation = _go_download_bootstrap_sdk_impl,
+    attrs = {
+        "goos": attr.string(),
+        "goarch": attr.string(),
+        "sdks": attr.string_list_dict(),
+        "experiments": attr.string_list(
+            doc = "Go experiments to enable via GOEXPERIMENT",
+        ),
+        "urls": attr.string_list(default = ["https://dl.google.com/go/{}"]),
+        "version": attr.string(),
+        "strip_prefix": attr.string(default = "go"),
+        "bootstrap_strip_prefix": attr.string(default = "go"),
+        "patches": attr.label_list(
+            doc = "A list of patches to apply to the source SDK before bootstrapping.",
+        ),
+        "patch_strip": attr.int(
+            default = 0,
+            doc = "The number of leading path segments to be stripped from the file name in the patches.",
+        ),
+        "_sdk_build_file": attr.label(
+            default = Label("//go/private:BUILD.bootstrap.sdk.bazel"),
+        ),
+    },
+)
+
 def _define_version_constants(version, prefix = ""):
     pv = parse_version(version)
     if pv == None or len(pv) < 3:
@@ -180,7 +294,7 @@ def _get_patch_args(patch_strip):
         return ["-p{}".format(patch_strip)]
     return []
 
-def go_toolchains_single_definition(ctx, *, prefix, goos, goarch, sdk_repo, sdk_type, sdk_version):
+def go_toolchains_single_definition(ctx, *, prefix, goos, goarch, sdk_repo, sdk_type, sdk_version, sdk_source):
     if not goos and not goarch:
         goos, goarch = detect_host_platform(ctx)
     else:
@@ -223,6 +337,7 @@ def go_toolchains_single_definition(ctx, *, prefix, goos, goarch, sdk_repo, sdk_
     prerelease = {identifier_prefix}PRERELEASE_SUFFIX,
     sdk_name = "{sdk_repo}",
     sdk_type = "{sdk_type}",
+    sdk_source = "{sdk_source}",
 )
 """.format(
         prefix = prefix,
@@ -231,6 +346,7 @@ def go_toolchains_single_definition(ctx, *, prefix, goos, goarch, sdk_repo, sdk_
         goarch = goarch,
         goos = goos,
         sdk_type = sdk_type,
+        sdk_source = sdk_source,
     ))
 
     return struct(
@@ -245,8 +361,9 @@ def go_toolchains_build_file_content(
         goarchs,
         sdk_repos,
         sdk_types,
-        sdk_versions):
-    if not _have_same_length(prefixes, geese, goarchs, sdk_repos, sdk_types, sdk_versions):
+        sdk_versions,
+        sdk_sources):
+    if not _have_same_length(prefixes, geese, goarchs, sdk_repos, sdk_types, sdk_versions, sdk_sources):
         fail("all lists must have the same length")
 
     loads = [
@@ -265,6 +382,7 @@ def go_toolchains_build_file_content(
             sdk_repo = sdk_repos[i],
             sdk_type = sdk_types[i],
             sdk_version = sdk_versions[i],
+            sdk_source = sdk_sources[i],
         )
         loads.extend(definition.loads)
         chunks.extend(definition.chunks)
@@ -282,6 +400,7 @@ def _go_multiple_toolchains_impl(ctx):
             sdk_repos = ctx.attr.sdk_repos,
             sdk_types = ctx.attr.sdk_types,
             sdk_versions = ctx.attr.sdk_versions,
+            sdk_sources = ctx.attr.sdk_sources,
         ),
         executable = False,
     )
@@ -293,12 +412,13 @@ go_multiple_toolchains = repository_rule(
         "sdk_repos": attr.string_list(mandatory = True),
         "sdk_types": attr.string_list(mandatory = True),
         "sdk_versions": attr.string_list(mandatory = True),
+        "sdk_sources": attr.string_list(mandatory = True),
         "geese": attr.string_list(mandatory = True),
         "goarchs": attr.string_list(mandatory = True),
     },
 )
 
-def _go_toolchains(name, sdk_repo, sdk_type, sdk_version = None, goos = None, goarch = None):
+def _go_toolchains(name, sdk_repo, sdk_type, sdk_version = None, goos = None, goarch = None, sdk_source = "prebuilt"):
     go_multiple_toolchains(
         name = name,
         prefixes = [""],
@@ -307,6 +427,7 @@ def _go_toolchains(name, sdk_repo, sdk_type, sdk_version = None, goos = None, go
         sdk_repos = [sdk_repo],
         sdk_types = [sdk_type],
         sdk_versions = [sdk_version or ""],
+        sdk_sources = [sdk_source],
     )
 
 def go_download_sdk(name, register_toolchains = True, **kwargs):
@@ -322,6 +443,20 @@ def go_download_sdk(name, register_toolchains = True, **kwargs):
     if register_toolchains:
         _register_toolchains(name)
 
+def go_download_bootstrap_sdk(name, register_toolchains = True, **kwargs):
+    go_download_bootstrap_sdk_rule(name = name, **kwargs)
+    _go_toolchains(
+        name = name + "_toolchains",
+        sdk_repo = name,
+        sdk_type = "remote",
+        sdk_version = kwargs.get("version"),
+        goos = kwargs.get("goos"),
+        goarch = kwargs.get("goarch"),
+        sdk_source = "bootstrapped",
+    )
+    if register_toolchains:
+        _register_toolchains(name)
+
 def _go_local_sdk_impl(ctx):
     goroot = ctx.attr.path
     platform = _detect_sdk_platform(ctx, goroot)
@@ -433,6 +568,21 @@ def _remote_sdk(ctx, urls, strip_prefix, sha256):
         auth = auth,
     )
 
+def _download_bootstrap_sdk(ctx, *, urls, strip_prefix, sha256):
+    bootstrap_dir = "_bootstrap_sdk"
+    if len(urls) == 0:
+        fail("no urls specified")
+    ctx.report_progress("Downloading bootstrap Go toolchain")
+
+    auth = use_netrc(read_user_netrc(ctx), urls, {})
+    ctx.download_and_extract(
+        url = urls,
+        output = bootstrap_dir,
+        stripPrefix = strip_prefix,
+        sha256 = sha256,
+        auth = auth,
+    )
+
 def _local_sdk(ctx, path):
     for entry in ctx.path(path).readdir():
         if ctx.path(entry.basename).exists:
@@ -558,21 +708,27 @@ def _parse_versions_json(data):
 
     Return:
         A dict mapping version strings (like "1.15.5") to dicts mapping
-        platform names (like "linux_amd64") to pairs of filenames
-        (like "go1.15.5.linux-amd64.tar.gz") and hex-encoded SHA-256 sums.
+        platform names (like "linux_amd64") plus the key "source" to pairs of
+        filenames (like "go1.15.5.linux-amd64.tar.gz") and hex-encoded SHA-256
+        sums.
     """
     sdks = json.decode(data)
-    return {
-        sdk["version"][len("go"):]: {
-            "%s_%s" % (file["os"], file["arch"]): (
-                file["filename"],
-                file["sha256"],
-            )
-            for file in sdk["files"]
-            if file["kind"] == "archive"
-        }
-        for sdk in sdks
-    }
+    parsed = {}
+    for sdk in sdks:
+        entries = {}
+        for file in sdk["files"]:
+            if file["kind"] == "archive":
+                entries["%s_%s" % (file["os"], file["arch"])] = (
+                    file["filename"],
+                    file["sha256"],
+                )
+            elif file["kind"] == "source":
+                entries["source"] = (
+                    file["filename"],
+                    file["sha256"],
+                )
+        parsed[sdk["version"][len("go"):]] = entries
+    return parsed
 
 def fetch_sdks_by_version(ctx, allow_fail = False):
     result = ctx.download(
@@ -663,7 +819,13 @@ def go_register_toolchains(version = None, nogo = None, go_version = None, exper
     if not version:
         version = go_version  # old name
 
-    sdk_kinds = ("go_download_sdk_rule", "go_host_sdk_rule", "_go_local_sdk", "go_wrap_sdk_rule")
+    sdk_kinds = (
+        "go_download_bootstrap_sdk_rule",
+        "go_download_sdk_rule",
+        "go_host_sdk_rule",
+        "_go_local_sdk",
+        "go_wrap_sdk_rule",
+    )
     existing_rules = native.existing_rules()
     sdk_rules = [r for r in existing_rules.values() if r["kind"] in sdk_kinds]
     if len(sdk_rules) == 0 and "go_sdk" in existing_rules:
diff --git a/go/private/sdk_build_defs.bzl b/go/private/sdk_build_defs.bzl
new file mode 100644
index 00000000..36ef301d
--- /dev/null
+++ b/go/private/sdk_build_defs.bzl
@@ -0,0 +1,29 @@
+# Copyright 2014 The Bazel Authors. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+STDLIB_SRCS_EXCLUDE = [
+    "src/**/*_test.go",
+    "src/**/testdata/**",
+    # Only used by tests, cgo fails with linux before 3.17
+    "src/crypto/internal/sysrand/internal/seccomp/**",
+    "src/encoding/json/internal/jsontest/**",
+    "src/log/slog/internal/benchmarks/**",
+    "src/log/slog/internal/slogtest/**",
+    "src/internal/obscuretestdata/**",
+    "src/internal/testpty/**",
+    "src/net/internal/cgotest/**",
+    "src/net/internal/socktest/**",
+    "src/reflect/internal/example*/**",
+    "src/runtime/internal/startlinetest/**",
+]
diff --git a/go/toolchain/BUILD.bazel b/go/toolchain/BUILD.bazel
index fe668e51..f823b847 100644
--- a/go/toolchain/BUILD.bazel
+++ b/go/toolchain/BUILD.bazel
@@ -19,6 +19,29 @@ string_flag(
     build_setting_default = "",
 )
 
+string_flag(
+    name = "source",
+    build_setting_default = "prebuilt",
+    values = [
+        "bootstrapped",
+        "prebuilt",
+    ],
+)
+
+config_setting(
+    name = "source_bootstrapped",
+    flag_values = {
+        ":source": "bootstrapped",
+    },
+)
+
+config_setting(
+    name = "source_prebuilt",
+    flag_values = {
+        ":source": "prebuilt",
+    },
+)
+
 filegroup(
     name = "all_rules",
     srcs = glob(["*.bzl"]),
diff --git a/tests/core/compatibility/BUILD.bazel b/tests/core/compatibility/BUILD.bazel
index 116cccd9..2f2bb310 100644
--- a/tests/core/compatibility/BUILD.bazel
+++ b/tests/core/compatibility/BUILD.bazel
@@ -9,4 +9,8 @@ go_cross_binary(
     name = "hello_old",
     sdk_version = "1.22",
     target = ":hello",
+    target_compatible_with = select({
+        "@io_bazel_rules_go//go/toolchain:source_bootstrapped": ["@platforms//:incompatible"],
+        "//conditions:default": [],
+    }),
 )
diff --git a/tests/core/starlark/sdk_tests.bzl b/tests/core/starlark/sdk_tests.bzl
index a68449cd..1c8c1b9b 100644
--- a/tests/core/starlark/sdk_tests.bzl
+++ b/tests/core/starlark/sdk_tests.bzl
@@ -12,6 +12,7 @@ def _go_toolchains_single_definition_with_version_test(ctx):
         sdk_repo = "sdk_repo",
         sdk_type = "download",
         sdk_version = "1.20.2rc1",
+        sdk_source = "prebuilt",
     )
     asserts.equals(env, [], result.loads)
     asserts.equals(env, [
@@ -32,6 +33,7 @@ _123_PREFIX_PRERELEASE_SUFFIX = "rc1"
     prerelease = _123_PREFIX_PRERELEASE_SUFFIX,
     sdk_name = "sdk_repo",
     sdk_type = "download",
+    sdk_source = "prebuilt",
 )
 """,
     ], result.chunks)
@@ -51,6 +53,7 @@ def _go_toolchains_single_definition_without_version_test(ctx):
         sdk_repo = "sdk_repo",
         sdk_type = "download",
         sdk_version = None,
+        sdk_source = "prebuilt",
     )
     asserts.equals(env, ["""load(
     "@sdk_repo//:version.bzl",
@@ -72,6 +75,7 @@ def _go_toolchains_single_definition_without_version_test(ctx):
     prerelease = _123_PREFIX_PRERELEASE_SUFFIX,
     sdk_name = "sdk_repo",
     sdk_type = "download",
+    sdk_source = "prebuilt",
 )
 """,
     ], result.chunks)
